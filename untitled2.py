# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ygeUXb7xrHFyDw00RKpwV7RmJXKOCgAb
"""

#STEP 1 — Install & Import PyBullet (Colab-safe)

#Run this first cell:
!pip install pybullet imageio imageio-ffmpeg

#STEP 2 — Set Up Simulation (Headless, Video Recording)
import pybullet as p
import pybullet_data
import time
import numpy as np
import imageio

# Start PyBullet in DIRECT mode (headless)
p.connect(p.DIRECT)
p.setAdditionalSearchPath(pybullet_data.getDataPath())
p.setGravity(0, 0, -9.8)

# For video
frames = []

#STEP 3 — Load Ground + Ramp + Car + Internal Cube
# Ground plane
plane = p.loadURDF("plane.urdf")

# A small ramp (inclined box)
ramp = p.createCollisionShape(p.GEOM_BOX, halfExtents=[2, 2, 0.2])
ramp_body = p.createMultiBody(
    baseMass=0,
    baseCollisionShapeIndex=ramp,
    basePosition=[0, 0, 0.2],
    baseOrientation=p.getQuaternionFromEuler([0.4, 0, 0]) # inclined
)

# Car body (a simple box)
car_mass = 100
car_col = p.createCollisionShape(p.GEOM_BOX, halfExtents=[1, 0.5, 0.3])
car = p.createMultiBody(car_mass, car_col, basePosition=[-5, 0, 1])

# Heavy internal cube sliding along Y-axis
cube_mass = 25   # ~0.25 of car mass
cube_col = p.createCollisionShape(p.GEOM_BOX, halfExtents=[0.2, 0.2, 0.2])
cube = p.createMultiBody(cube_mass, cube_col, basePosition=[-5, 0, 1.5])

# Disable default cube dynamics — we want to control position manually
p.changeDynamics(cube, -1, linearDamping=0, angularDamping=0)

#STEP 4 — Basic PID Controller for Cube Motion Along Y-axis
# PID parameters
Kp = 20.0
Ki = 0.0
Kd = 4.0

prev_error = 0
integral = 0

def pid_control(target_angle, current_angle, dt):
    global prev_error, integral
    error = target_angle - current_angle
    integral += error * dt
    derivative = (error - prev_error) / dt
    prev_error = error
    return Kp*error + Ki*integral + Kd*derivative

# ----------------------------------------------------
# STEP 5 — SIMULATION LOOP (Matplotlib Rendering)
# ----------------------------------------------------

import matplotlib.pyplot as plt

t = 0
dt = 1./240.
jump_given = False
failure_detected = False

frames = []
W, H = 360, 240

for step in range(2000):

    # Impulse
    if not jump_given:
        p.applyExternalForce(
            car, -1,
            forceObj=[15000, 0, 0],
            posObj=[0, 0, 0],
            flags=p.LINK_FRAME
        )
        jump_given = True

    # Get car orientation
    pos, orn = p.getBasePositionAndOrientation(car)
    roll, pitch, yaw = p.getEulerFromQuaternion(orn)

    # PID control in air
    if pos[2] > 1.2:
        control_out = pid_control(0, pitch, dt)
        cube_y = np.clip(control_out * 0.02, -0.6, 0.6)

        p.resetBasePositionAndOrientation(
            cube,
            [pos[0], pos[1] + cube_y, pos[2] + 0.5],
            [0, 0, 0, 1]
        )

    # Landing detection
    #if pos[2] < 1.1:
        #if abs(pitch) > 0.5 or abs(roll) > 0.5:
            #failure_detected = True
        #break

    p.stepSimulation()

    # -----------------------------------------
    # Manual Rendering via Matplotlib (top view)
    # -----------------------------------------
    fig, ax = plt.subplots(figsize=(3.6, 2.4))
    ax.set_xlim(pos[0] - 5, pos[0] + 5)
    ax.set_ylim(-5, 5)
    ax.set_aspect('equal')

    # Plot car (rectangle)
    car_x, car_y, _ = pos
    ax.add_patch(plt.Rectangle((car_x-1, car_y-0.5), 2, 1, color='blue', alpha=0.6))

    # Plot cube
    cube_pos, _ = p.getBasePositionAndOrientation(cube)
    cx, cy, _ = cube_pos
    ax.add_patch(plt.Circle((cx, cy), 0.2, color='red'))

    ax.set_title(f"Step {step}")
    ax.axis('off')

    # Convert figure to RGB frame
    # Convert figure to RGB frame
fig.canvas.draw()
frame = np.frombuffer(fig.canvas.tostring_rgb(), dtype=np.uint8)
frame = frame.reshape(fig.canvas.get_width_height()[::-1] + (3,))
frames.append(frame)


# -----------------------------------------
# Save GIF
# -----------------------------------------
import imageio
gif_path = "/content/car_flip_controller.gif"
imageio.mimsave(gif_path, frames, fps=30)

print("DONE")
print("Failure detected:", failure_detected)
print("Saved to:", gif_path)